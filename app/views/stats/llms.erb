<div class="mb-3">
  <div class="row">
    <div class="col-md-3">
      <label for="index-selector" class="form-label">Index:</label>
      <select id="index-selector" class="form-control">
        <option value="intelligence">Intelligence</option>
        <option value="agentic" selected>Agentic</option>
        <option value="coding">Coding</option>
        <option value="math">Math</option>
      </select>
    </div>
    <div class="col-md-2">
      <label for="reasoning-filter" class="form-label">Reasoning:</label>
      <select id="reasoning-filter" class="form-control">
        <option value="">All</option>
        <option value="reasoning">Yes</option>
        <option value="non-reasoning">No</option>
      </select>
    </div>
    <div class="col-md-2">
      <label for="open-source-filter" class="form-label">Open Source:</label>
      <select id="open-source-filter" class="form-control">
        <option value="">All</option>
        <option value="yes">Yes</option>
        <option value="no">No</option>
      </select>
    </div>
    <div class="col-md-2">
      <label for="release-filter" class="form-label">Released in last:</label>
      <select id="release-filter" class="form-control">
        <option value="">All time</option>
        <option value="1">1 month</option>
        <option value="3" selected>3 months</option>
        <option value="6">6 months</option>
        <option value="12">12 months</option>
        <option value="24">24 months</option>
      </select>
    </div>
  </div>
</div>

<div class="mb-4">
  <div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h5 class="mb-0" id="chart-title"></h5>
      <button id="reset-zoom" class="btn btn-sm btn-outline-secondary">Reset Zoom</button>
    </div>
    <div class="card-body">
      <div class="row">
        <div class="col-md-9">
          <canvas id="cost-intelligence-chart" height="140"></canvas>
        </div>
        <div class="col-md-3">
          <div id="pareto-list" class="mt-2">Loading...</div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="table-responsive">
  <table id="models-table" class="table table-hover">
    <thead>
      <tr>
        <th>Model</th>
        <th>Creator</th>
        <th>Release</th>
        <th>Reasoning</th>
        <th>Open Source</th>
        <th>Intelligence Index</th>
        <th>Agentic Index</th>
        <th>Coding Index</th>
        <th>Math Index</th>
        <th>Cost to Run</th>
      </tr>
    </thead>
    <tbody>
      <% @models.each do |model| %>
        <tr>
          <td>
            <strong><%= model['name'].gsub(/\s*\(Reasoning\)\s*/i, '').gsub(/\s*\(Non-reasoning\)\s*/i, '').strip %><% if model['reasoning_model'] %> <i class="bi bi-lightbulb"></i><% end %></strong>
            <br>
            <small class="text-muted"><code><%= model['slug'] %></code></small>
          </td>
          <td>
            <%= model.dig('model_creators', 'name') || 'N/A' %>
          </td>
          <td data-order="<%= model['release_date'] || '0000-00-00' %>">
            <% if model['release_date'] %>
              <%= Date.parse(model['release_date']).strftime('%b %Y') rescue model['release_date'] %>
            <% else %>
              <span class="text-muted">—</span>
            <% end %>
          </td>
          <td>
            <% if model['reasoning_model'] %>
              <span class="badge badge-success">Reasoning</span>
            <% else %>
              <span class="badge badge-secondary">Non-reasoning</span>
            <% end %>
          </td>
          <td>
            <% if model['is_open_weights'] %>
              <span class="badge badge-success">Yes</span>
            <% else %>
              <span class="badge badge-secondary">No</span>
            <% end %>
          </td>
          <td data-order="<%= model['intelligence_index'] || 0 %>">
            <% if (score = model['intelligence_index']) %>
              <%= sprintf('%.1f', score) %>
            <% else %>
              <span class="text-muted">—</span>
            <% end %>
          </td>
          <td data-order="<%= model['agentic_index'] || 0 %>">
            <% if (score = model['agentic_index']) %>
              <%= sprintf('%.1f', score) %>
            <% else %>
              <span class="text-muted">—</span>
            <% end %>
          </td>
          <td data-order="<%= model['coding_index'] || 0 %>">
            <% if (score = model['coding_index']) %>
              <%= sprintf('%.1f', score) %>
            <% else %>
              <span class="text-muted">—</span>
            <% end %>
          </td>
          <td data-order="<%= model['math_index'] || 0 %>">
            <% if (score = model['math_index']) %>
              <%= sprintf('%.1f', score) %>
            <% else %>
              <span class="text-muted">—</span>
            <% end %>
          </td>
          <td data-order="<%= model['cost_to_run'] || 0 %>">
            <% if model['cost_to_run'] %>
              $<%= sprintf('%.0f', model['cost_to_run']) %>
            <% else %>
              <span class="text-muted">—</span>
            <% end %>
          </td>
        </tr>
      <% end %>
    </tbody>
  </table>
</div>

<script>
  var modelsData = <%== @models.map { |m|
    {
      name: m['name'],
      intelligenceIndex: (m['intelligence_index'] || 0).to_f,
      agenticIndex: (m['agentic_index'] || 0).to_f,
      codingIndex: (m['coding_index'] || 0).to_f,
      mathIndex: (m['math_index'] || 0).to_f,
      costToRun: (m['cost_to_run'] || 0).to_f,
      reasoningModel: !!m['reasoning_model'],
      isOpenWeights: !!m['is_open_weights'],
      releaseDate: m['release_date']
    }
  }.to_json %>;

  var indexLabels = {
    intelligence: 'Intelligence Index',
    agentic: 'Agentic Index',
    coding: 'Coding Index',
    math: 'Math Index'
  };

  // Clean model names for display (remove reasoning/non-reasoning suffixes)
  function cleanModelName(name) {
    return name.replace(/\s*\(Reasoning\)\s*/gi, '').replace(/\s*\(Non-reasoning\)\s*/gi, '').trim();
  }

  $(function() {
    var table = $('#models-table').DataTable({
      paging: false,
      searching: true,
      order: [[6, 'desc']], // Sort by Agentic Index descending
      columnDefs: [
        { type: 'num', targets: [5, 6, 7, 8, 9] } // Numeric columns
      ]
    });

    // Custom plugin for leader lines with collision avoidance
    var leaderLinePlugin = {
      id: 'leaderLines',
      afterDatasetsDraw: function(chart) {
        var ctx = chart.ctx;
        var labels = [];
        var allPoints = []; // All Pareto point positions
        var labelHeight = 12;
        var labelPadding = 4;
        var baseLineLength = 25;
        var pointRadius = 12; // Approximate point radius for collision

        // First pass: collect all Pareto points
        chart.data.datasets.forEach(function(dataset, datasetIndex) {
          if (dataset.type === 'line') return;
          var meta = chart.getDatasetMeta(datasetIndex);
          meta.data.forEach(function(element, index) {
            var dataPoint = dataset.data[index];
            if (!dataPoint.isPareto) return;

            ctx.font = '10px sans-serif';
            var displayLabel = cleanModelName(dataPoint.label);
            var textWidth = ctx.measureText(displayLabel).width;

            var pointInfo = {
              label: displayLabel,
              pointX: element.x,
              pointY: element.y,
              textWidth: textWidth,
              angle: 0,
              lineLength: baseLineLength
            };
            labels.push(pointInfo);
            allPoints.push({ x: element.x, y: element.y });
          });
        });

        // Sort by x position (right to left, highest cost first)
        labels.sort(function(a, b) { return b.pointX - a.pointX; });

        // Calculate label end positions
        function calcLabelBox(lbl) {
          var endX = lbl.pointX + Math.cos(lbl.angle) * lbl.lineLength;
          var endY = lbl.pointY + Math.sin(lbl.angle) * lbl.lineLength;
          return {
            x: endX + labelPadding,
            y: endY - labelHeight / 2,
            width: lbl.textWidth,
            height: labelHeight,
            endX: endX,
            endY: endY
          };
        }

        // Check if two boxes overlap
        function boxesOverlap(a, b) {
          return !(a.x + a.width < b.x || b.x + b.width < a.x ||
                   a.y + a.height < b.y || b.y + b.height < a.y);
        }

        // Check if a box overlaps with a circle (point)
        function boxOverlapsPoint(box, point) {
          // Find closest point on box to circle center
          var closestX = Math.max(box.x, Math.min(point.x, box.x + box.width));
          var closestY = Math.max(box.y, Math.min(point.y, box.y + box.height));
          var dx = point.x - closestX;
          var dy = point.y - closestY;
          return (dx * dx + dy * dy) < (pointRadius * pointRadius);
        }

        // Try to resolve collisions iteratively
        var angles = [0, Math.PI/6, Math.PI/4, Math.PI/3, Math.PI/2.5, -Math.PI/8, -Math.PI/6];
        var lengths = [25, 35, 45, 55, 65, 75];

        for (var i = 0; i < labels.length; i++) {
          var currentLabel = labels[i];
          var bestConfig = { angle: 0, lineLength: baseLineLength, collisions: Infinity };

          // Try different angle/length combinations
          for (var ai = 0; ai < angles.length; ai++) {
            for (var li = 0; li < lengths.length; li++) {
              currentLabel.angle = angles[ai];
              currentLabel.lineLength = lengths[li];
              var currentBox = calcLabelBox(currentLabel);

              var collisionCount = 0;

              // Check against all previous labels
              for (var j = 0; j < i; j++) {
                var otherBox = calcLabelBox(labels[j]);
                if (boxesOverlap(currentBox, otherBox)) {
                  collisionCount++;
                }
              }

              // Check against all Pareto points
              for (var p = 0; p < allPoints.length; p++) {
                if (boxOverlapsPoint(currentBox, allPoints[p])) {
                  collisionCount++;
                }
              }

              // Prefer shorter lines and smaller angles when no collisions
              var score = collisionCount * 1000 + lengths[li] + Math.abs(angles[ai]) * 10;
              if (score < bestConfig.collisions * 1000 + bestConfig.lineLength + Math.abs(bestConfig.angle) * 10) {
                bestConfig = { angle: angles[ai], lineLength: lengths[li], collisions: collisionCount };
              }

              if (collisionCount === 0) break; // Found good config, stop searching lengths
            }
            if (bestConfig.collisions === 0) break; // Found good config, stop searching angles
          }

          currentLabel.angle = bestConfig.angle;
          currentLabel.lineLength = bestConfig.lineLength;
        }

        // Draw all labels with resolved positions
        labels.forEach(function(lbl) {
          var box = calcLabelBox(lbl);

          ctx.save();
          // Draw leader line
          ctx.beginPath();
          ctx.moveTo(lbl.pointX, lbl.pointY);
          ctx.lineTo(box.endX, box.endY);
          ctx.strokeStyle = '#999';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Draw label
          ctx.font = '10px sans-serif';
          ctx.fillStyle = '#666';
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'left';
          ctx.fillText(lbl.label, box.endX + labelPadding, box.endY);
          ctx.restore();
        });
      }
    };

    // Initialize scatter chart
    var ctx = document.getElementById('cost-intelligence-chart').getContext('2d');
    Chart.register(ChartDataLabels);
    var chart = new Chart(ctx, {
      type: 'scatter',
      data: { datasets: [] },
      plugins: [leaderLinePlugin],
      options: {
        responsive: true,
        maintainAspectRatio: true,
        layout: {
          padding: { left: 20, right: 20 }
        },
        plugins: {
          datalabels: {
            display: false // Labels drawn by leaderLinePlugin
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                var point = context.raw;
                return cleanModelName(point.label) + ': Cost $' + point.x.toFixed(0) + ', Intelligence ' + point.y.toFixed(1);
              }
            }
          },
          legend: {
            display: true,
            position: 'bottom',
            labels: {
              usePointStyle: true,
              padding: 20
            }
          },
          zoom: {
            pan: {
              enabled: true,
              mode: 'xy'
            },
            zoom: {
              wheel: { enabled: true },
              pinch: { enabled: true },
              mode: 'xy'
            }
          }
        },
        scales: {
          x: {
            type: 'logarithmic',
            title: { display: true, text: 'Cost to Run ($)', font: { weight: 'bold' } },
            grid: { color: 'rgba(0,0,0,0.05)' }
          },
          y: {
            title: { display: true, text: 'Intelligence Index', font: { weight: 'bold' } },
            grid: { color: 'rgba(0,0,0,0.05)' }
          }
        }
      }
    });

    // Reset zoom button
    $('#reset-zoom').on('click', function() {
      chart.resetZoom();
    });

    function getIndexValue(model, indexType) {
      switch(indexType) {
        case 'agentic': return model.agenticIndex;
        case 'coding': return model.codingIndex;
        case 'math': return model.mathIndex;
        default: return model.intelligenceIndex;
      }
    }

    function updateChart() {
      var selectedIndex = $('#index-selector').val();
      var reasoningFilter = $('#reasoning-filter').val();
      var openSourceFilter = $('#open-source-filter').val();
      var releaseFilter = $('#release-filter').val();

      // Update title and axis label
      var indexLabel = indexLabels[selectedIndex];
      $('#chart-title').text(indexLabel + ' vs Cost to Run');
      chart.options.scales.y.title.text = indexLabel;

      // Calculate cutoff date for release filter
      var cutoffDate = null;
      if (releaseFilter) {
        cutoffDate = new Date();
        cutoffDate.setMonth(cutoffDate.getMonth() - parseInt(releaseFilter));
      }

      // Filter models based on current filters
      var filteredModels = modelsData.filter(function(model) {
        var reasoningMatch = true;
        var openSourceMatch = true;
        var releaseMatch = true;

        if (reasoningFilter === 'reasoning') reasoningMatch = model.reasoningModel;
        else if (reasoningFilter === 'non-reasoning') reasoningMatch = !model.reasoningModel;

        if (openSourceFilter === 'yes') openSourceMatch = model.isOpenWeights;
        else if (openSourceFilter === 'no') openSourceMatch = !model.isOpenWeights;

        if (cutoffDate && model.releaseDate) {
          var modelDate = new Date(model.releaseDate);
          releaseMatch = modelDate >= cutoffDate;
        } else if (cutoffDate) {
          releaseMatch = false;
        }

        var indexValue = getIndexValue(model, selectedIndex);
        return reasoningMatch && openSourceMatch && releaseMatch && indexValue > 0 && model.costToRun > 0;
      });

      // Group by reasoning and open source
      // Colors: primary green for open source, grey for closed source
      // Shapes: triangle for reasoning (like a bright idea), circle for non-reasoning
      var openColor = '#4F9DFA';
      var closedColor = '#000000';

      var groups = {
        'Reasoning + Open Source': {
          filter: function(m) { return m.reasoningModel && m.isOpenWeights; },
          color: openColor,
          pointStyle: 'triangle'
        },
        'Reasoning + Closed': {
          filter: function(m) { return m.reasoningModel && !m.isOpenWeights; },
          color: closedColor,
          pointStyle: 'triangle'
        },
        'Non-reasoning + Open Source': {
          filter: function(m) { return !m.reasoningModel && m.isOpenWeights; },
          color: openColor,
          pointStyle: 'circle'
        },
        'Non-reasoning + Closed': {
          filter: function(m) { return !m.reasoningModel && !m.isOpenWeights; },
          color: closedColor,
          pointStyle: 'circle'
        }
      };

      // Calculate Pareto frontier FIRST so we can label only those points
      var allPoints = filteredModels.map(function(m) {
        return { x: m.costToRun, y: getIndexValue(m, selectedIndex), label: m.name, reasoningModel: m.reasoningModel };
      });

      // Sort by cost (ascending)
      allPoints.sort(function(a, b) { return a.x - b.x; });

      // Find Pareto-optimal points (with epsilon for near-ties)
      var paretoPoints = [];
      var paretoInfo = {}; // Store both membership and index
      var maxIntelligence = -Infinity;
      var epsilon = 1.0; // Include points within 1 intelligence point of the frontier

      for (var i = 0; i < allPoints.length; i++) {
        if (allPoints[i].y > maxIntelligence - epsilon) {
          paretoInfo[allPoints[i].label] = paretoPoints.length; // Store index
          paretoPoints.push(allPoints[i]);
          if (allPoints[i].y > maxIntelligence) {
            maxIntelligence = allPoints[i].y;
          }
        }
      }


      chart.data.datasets = [];

      Object.keys(groups).forEach(function(label) {
        var group = groups[label];
        var models = filteredModels.filter(group.filter);
        if (models.length > 0) {
          var dataPoints = models.map(function(m) {
            var pIdx = paretoInfo[m.name];
            return {
              x: m.costToRun,
              y: getIndexValue(m, selectedIndex),
              label: m.name,
              isPareto: pIdx !== undefined,
              paretoIndex: pIdx || 0
            };
          });
          chart.data.datasets.push({
            label: label,
            data: dataPoints,
            backgroundColor: dataPoints.map(function(point) {
              return group.color + (point.isPareto ? 'ff' : '33');
            }),
            borderWidth: 0,
            pointStyle: group.pointStyle,
            pointRadius: 10,
            pointHoverRadius: 12,
            datalabels: { display: false }
          });
        }
      });

      // Add Pareto frontier as a line
      if (paretoPoints.length > 1) {
        chart.data.datasets.unshift({
          label: 'Pareto Frontier',
          data: paretoPoints,
          type: 'line',
          borderColor: '#ff6b6b',
          borderWidth: 2,
          borderDash: [5, 5],
          fill: false,
          pointRadius: 0,
          pointStyle: 'line',
          tension: 0,
          datalabels: { display: false }
        });
      }

      // Update Pareto list (sorted by cost, highest first)
      if (paretoPoints.length > 0) {
        var sortedPareto = paretoPoints.slice().sort(function(a, b) { return b.x - a.x; });
        var paretoHtml = '<ul class="list-unstyled mb-0">' + sortedPareto.map(function(p) {
          var lightbulbIcon = p.reasoningModel ? ' <i class="bi bi-lightbulb"></i>' : '';
          return '<li><strong>' + cleanModelName(p.label) + lightbulbIcon + '</strong> <span class="text-muted">($' + p.x.toFixed(0) + ' @ ' + p.y.toFixed(1) + ')</span></li>';
        }).join('') + '</ul>';
        $('#pareto-list').html(paretoHtml);
      } else {
        $('#pareto-list').html('<em>No models match current filters</em>');
      }

      chart.update();
    }

    // Custom filter function for table
    $.fn.dataTable.ext.search.push(
      function(settings, data, dataIndex) {
        var reasoningFilter = $('#reasoning-filter').val();
        var openSourceFilter = $('#open-source-filter').val();
        var releaseFilter = $('#release-filter').val();

        if (settings.nTable.id !== 'models-table') return true;

        var row = table.row(dataIndex).node();
        var reasoningCell = $(row).find('td:eq(3)');
        var openSourceCell = $(row).find('td:eq(4)');

        var reasoningMatch = true;
        var openSourceMatch = true;
        var releaseMatch = true;

        if (reasoningFilter === 'reasoning') {
          reasoningMatch = reasoningCell.find('.badge-success').length > 0 && reasoningCell.text().includes('Reasoning');
        } else if (reasoningFilter === 'non-reasoning') {
          reasoningMatch = reasoningCell.find('.badge-secondary').length > 0 && reasoningCell.text().includes('Non-reasoning');
        }

        if (openSourceFilter === 'yes') {
          openSourceMatch = openSourceCell.find('.badge-success').length > 0 && openSourceCell.text().includes('Yes');
        } else if (openSourceFilter === 'no') {
          openSourceMatch = openSourceCell.find('.badge-secondary').length > 0 && openSourceCell.text().includes('No');
        }

        if (releaseFilter) {
          var cutoffDate = new Date();
          cutoffDate.setMonth(cutoffDate.getMonth() - parseInt(releaseFilter));
          var cellData = $(row).find('td:eq(2)').data('order') || '';
          if (cellData && cellData !== '0000-00-00') {
            var modelDate = new Date(cellData);
            releaseMatch = modelDate >= cutoffDate;
          } else {
            releaseMatch = false;
          }
        }

        return reasoningMatch && openSourceMatch && releaseMatch;
      }
    );

    // Apply filters when dropdowns change
    $('#index-selector, #reasoning-filter, #open-source-filter, #release-filter').on('change', function() {
      table.draw();
      updateChart();
    });

    // Initial chart render
    updateChart();
  });
</script>
